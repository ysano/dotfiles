# マイグレーションガイド生成コマンド

依存関係、フレームワーク、アーキテクチャ変更のアップグレード用の包括的なマイグレーションガイドを作成します。

## 手順

マイグレーションガイド作成の体系的なアプローチに従ってください： **$ARGUMENTS**

1. **マイグレーション範囲分析**
   - マイグレーション対象（フレームワーク、ライブラリ、アーキテクチャなど）を特定
   - ソースとターゲットのバージョンまたは技術を決定
   - マイグレーションの規模と複雑さを評価
   - 影響を受けるシステムとコンポーネントを特定

2. **影響評価**
   - バージョン間の破壊的変更を分析
   - 非推奨機能とAPIを特定
   - 新機能と能力を確認
   - 互換性要件と制約を評価
   - パフォーマンスとセキュリティの影響を評価

3. **前提条件と要件**
   - ターゲットバージョンのシステム要件を文書化
   - 必要なツールと依存関係をリストアップ
   - 最小バージョンと互換性要件を明確化
   - 必要なスキルとチーム準備を特定
   - インフラストラクチャと環境ニーズを概説

4. **マイグレーション前準備**
   - 包括的なバックアップ戦略を作成
   - 開発とテスト環境を設定
   - 現在のシステム状態と設定を文書化
   - ロールバック手順と緊急時計画を確立
   - マイグレーションのタイムラインとマイルストーンを作成

5. **段階的マイグレーションプロセス**
   
   **フレームワークアップグレードの例:**
   ```markdown
   ## ステップ1: 環境設定
   1. 開発環境の更新
   2. 新しいフレームワークバージョンのインストール
   3. ビルドツールと依存関係の更新
   4. IDEとツールの設定
   
   ## ステップ2: 依存関係の更新
   1. package.json/requirements.txtの更新
   2. 依存関係の競合解決
   3. 関連ライブラリの更新
   4. 互換性テスト
   
   ## ステップ3: コードマイグレーション
   1. インポート文の更新
   2. 非推奨APIの置換
   3. 設定ファイルの更新
   4. ビルドスクリプトの修正
   ```

6. **破壊的変更の文書化**
   - 例付きで全ての破壊的変更をリストアップ
   - 変更前後のコード比較を提供
   - 変更の根拠を説明
   - 削除された機能の代替アプローチを提案

   **破壊的変更の例:**
   ```markdown
   ### 削除: `oldMethod()`
   **変更前:**
   ```javascript
   const result = library.oldMethod(param1, param2);
   ```
   
   **変更後:**
   ```javascript
   const result = library.newMethod({ 
     param1: param1, 
     param2: param2 
   });
   ```
   
   **根拠:** 型安全性と拡張性の向上
   ```

7. **設定変更**
   - 設定ファイルの更新を文書化
   - 新しい設定オプションを説明
   - 設定マイグレーションスクリプトを提供
   - 環境固有の設定を表示

8. **データベースマイグレーション（該当する場合）**
   - データベーススキーママイグレーションスクリプトを作成
   - データ変換要件を文書化
   - バックアップと復元手順を提供
   - サンプルデータでマイグレーションをテスト
   - ゼロダウンタイムマイグレーションを計画

9. **テスト戦略**
   - 新しいAPI用に既存テストを更新
   - マイグレーション固有のテストケースを作成
   - 統合とE2Eテストを実装
   - パフォーマンステストと負荷テストを設定
   - テストシナリオと期待される結果を文書化

10. **パフォーマンス考慮事項**
    - パフォーマンス変更と最適化を文書化
    - ベンチマークガイドラインを提供
    - 潜在的なパフォーマンス回帰を特定
    - 監視とアラートの更新を提案
    - メモリとリソース使用量の変更を含める

11. **セキュリティ更新**
    - セキュリティ改善と変更を文書化
    - 認証と許可コードを更新
    - セキュリティ設定をレビューし更新
    - 依存関係セキュリティスキャンを更新
    - 新しいセキュリティベストプラクティスを文書化

12. **デプロイメント戦略**
    - 段階的ロールアウトアプローチを計画
    - デプロイメントスクリプトと自動化を作成
    - 監視とヘルスチェックを設定
    - ブルーグリーンやカナリアデプロイメントを計画
    - ロールバック手順を文書化

13. **一般的な問題とトラブルシューティング**
    
    ```markdown
    ## 一般的なマイグレーション問題
    
    ### 問題: インポート/モジュール解決エラー
    **症状:** Cannot resolve module 'old-package'
    **解決方法:** 
    1. インポート文を新しいパッケージ名に更新
    2. package.jsonで正しい依存関係を確認
    3. node_modulesをクリアして再インストール
    
    ### 問題: APIメソッドが見つからない
    **症状:** TypeError: oldMethod is not a function
    **解決方法:** ステップ3で文書化された新しいAPIで置換
    ```

14. **チームコミュニケーションとトレーニング**
    - チームトレーニング資料を作成
    - 知識共有セッションをスケジュール
    - 新しい開発ワークフローを文書化
    - コーディング標準とガイドラインを更新
    - クイックリファレンスガイドを作成

15. **ツールと自動化**
    - マイグレーションスクリプトとユーティリティを提供
    - コード変換ツール（codemods）を作成
    - 自動互換性チェックを設定
    - CI/CDパイプライン更新を実装
    - 検証と確認ツールを作成

16. **タイムラインとマイルストーン**
    
    ```markdown
    ## マイグレーションタイムライン
    
    ### フェーズ1: 準備（第1-2週）
    - [ ] 環境設定
    - [ ] チームトレーニング
    - [ ] 開発環境マイグレーション
    
    ### フェーズ2: 開発（第3-6週）
    - [ ] コアアプリケーションマイグレーション
    - [ ] テストと検証
    - [ ] パフォーマンス最適化
    
    ### フェーズ3: デプロイメント（第7-8週）
    - [ ] ステージングデプロイメント
    - [ ] 本番デプロイメント
    - [ ] 監視とサポート
    ```

17. **リスク緩和**
    - 潜在的なマイグレーションリスクを特定
    - 各リスクの緊急時計画を作成
    - エスカレーション手順を文書化
    - タイムライン延長シナリオを計画
    - ステークホルダーへのコミュニケーションを準備

18. **マイグレーション後タスク**
    - 非推奨コードと設定をクリーンアップ
    - ドキュメントとREADMEファイルを更新
    - 新しい実装をレビューし最適化
    - マイグレーション後のレトロスペクティブを実施
    - 将来のメンテナンスと更新を計画

19. **検証とテスト**
    - 包括的なテスト計画を作成
    - 受け入れ基準を文書化
    - 自動リグレッションテストを設定
    - ユーザー受け入れテストを計画
    - 監視とアラートを実装

20. **ドキュメント更新**
    - APIドキュメントを更新
    - 開発ガイドを改訂
    - デプロイメントドキュメントを更新
    - トラブルシューティングガイドを作成
    - チームオンボーディング資料を更新

**マイグレーションタイプと固有の考慮事項:**

**フレームワークマイグレーション（React 17 → 18）:**
- ReactとReactDOMのインポートを更新
- 非推奨ライフサイクルメソッドを置換
- テストライブラリメソッドを更新
- 並行機能とSuspenseを処理

**データベースマイグレーション（MySQL → PostgreSQL）:**
- SQL構文の違いを変換
- データタイプと制約を更新
- ストアドプロシージャを関数に移行
- ORM設定を更新

**クラウドマイグレーション（オンプレミス → AWS）:**
- アプリケーションのコンテナ化
- CI/CDパイプラインを更新
- クラウドサービスを設定
- Infrastructure as Codeを実装

**アーキテクチャマイグレーション（モノリス → マイクロサービス）:**
- サービス境界を特定
- サービス間通信を実装
- サービスディスカバリを設定
- データ一貫性戦略を計画

必ず実行してください:
- 最初に非本番環境で徹底的にテスト
- 進捗と問題を定期的にコミュニケーション
- 将来のマイグレーションのために学んだ教訓を文書化
- 実際の経験に基づいてマイグレーションガイドを更新し続ける