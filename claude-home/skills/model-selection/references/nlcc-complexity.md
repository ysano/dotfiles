## 自然言語サイクロマティック複雑度（NLCC）

AI エージェントへの指示（プロンプト）の複雑性を定量化する指標。
従来のコード複雑度（分岐数）のアナロジーを、自然言語の指示に適用する。

### 3つの構成要素

#### 1. 曖昧性（Ambiguity）

プロンプトの解釈が何通りに分岐し得るか。

| レベル | 例 | NLCC への影響 |
|--------|------|-------------|
| 低 | 「`auth.ts` の `login` 関数にログを追加して」 | 解釈は1通り |
| 中 | 「認証周りのエラーハンドリングを改善して」 | 数通りの解釈が可能 |
| 高 | 「いい感じに修正して」 | 無限の分岐、NLCC 極大 |

**対策**: 具体的なファイル名、関数名、期待する振る舞いを明示する。

#### 2. 依存性の幅（Width）

タスク完了のために参照しなければならないファイル・ドキュメントの数。
コンテキストウィンドウの消費量に直結する。

| レベル | 参照数 | 典型タスク |
|--------|--------|----------|
| 狭い | 1-3 ファイル | 単一関数の修正 |
| 中程度 | 4-10 ファイル | モジュール横断のリファクタリング |
| 広い | 10+ ファイル | アーキテクチャ変更、API 設計 |

**対策**: タスクを分割して Width を減らす。1サブエージェント = 1モジュール。

#### 3. 推論の深度（Depth）

最終アクションに至るまでの論理ステップ数。

| レベル | ステップ数 | 例 |
|--------|-----------|------|
| 浅い | 1-2 | 「この変数名を変更」 |
| 中程度 | 3-5 | 「A ならば B、B かつ C ならば D を実装」 |
| 深い | 6+ | 「障害の根本原因を特定し、再発防止策を設計」 |

**対策**: 深いタスクは Thinking Mode 付きモデルか Opus を使用する。

### Traffic Light System

NLCC の3要素を総合して信号機方式で判定する。

#### Green（即時実行可能）

- **条件**: 曖昧性=低、Width=狭い、Depth=浅い
- **推奨モデル**: Haiku / Sonnet
- **アクション**: そのまま実行

#### Yellow（注意して実行）

- **条件**: いずれかの要素が中〜高
- **推奨モデル**: Sonnet (Thinking) / Opus
- **アクション**: タスク分割を検討。分割不可なら上位モデルで実行

#### Red（人間に差し戻し）

- **条件**: 複数要素が高、または曖昧性が極大
- **推奨モデル**: -（実行前に要件明確化が必要）
- **アクション**: Inception フェーズへ差し戻し。人間による要件定義・仕様策定を要求

### Scope Check スキル設計パターン

タスク開始前にエージェント自身が複雑性を見積もる仕組み。

**動作フロー**:
1. ユーザーの要求を受け取る
2. 関連ファイル数（Width）を Glob/Grep で概算
3. 仕様の明確さ（Ambiguity）を分析
4. 依存チェーンの深さ（Depth）を推定
5. Traffic Light を出力

**出力例**:
```
🟡 Yellow: NLCC=中
- Ambiguity: 低（対象ファイル明確）
- Width: 中（5ファイル参照が必要）
- Depth: 中（3段階の条件分岐）
→ Sonnet (Thinking) 推奨。タスク分割の余地あり。
```

**応用**: エージェントの `model:` フィールドを固定する代わりに、Scope Check の結果に基づいてオーケストレーターがモデルを動的に選択する高度なパターンも可能。
