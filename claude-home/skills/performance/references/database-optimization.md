# データベースパフォーマンス最適化手順

データベースのクエリ・インデックス・スキーマを以下の 10 ステップで最適化する。

## 1. パフォーマンス分析

- 現在の DB パフォーマンスを分析しボトルネックを特定
- スロークエリログと実行プランをレビュー
- スキーマ設計と正規化を評価
- インデックス戦略とクエリパターンを評価
- リソース使用率 (CPU, メモリ, I/O) を監視

## 2. クエリ最適化

- `EXPLAIN ANALYZE` で実行プランを分析
- スロークエリログを有効化 (閾値: 1s)
  - PostgreSQL: `log_min_duration_statement = 1000`
  - MySQL: `long_query_time = 1`
- SELECT * を避け、必要なカラムのみ取得
- サブクエリを JOIN に書き換え (必要に応じて)
- WHERE 句でインデックスが使われることを確認

## 3. インデックス戦略

- インデックス使用率を分析 (idx_scan vs seq_scan)
- 未使用インデックスを特定・削除
- 複合インデックスのカラム順序を最適化 (選択性の高い順)
- カバリングインデックスで不要なテーブルアクセスを排除
- 部分インデックスで特定条件のクエリを高速化

## 4. スキーマ設計最適化

- 読み取り負荷の高いワークロードにはデノーマライゼーションを検討
- 大テーブルのパーティショニング (Range / Hash / List)
- 適切なデータ型の選択 (varchar vs text, int vs bigint)
- マテリアライズドビューで複雑な集計を事前計算

## 5. コネクションプール最適化

- プールサイズの適正化 (目安: CPU コア数 * 2 + ディスク数)
- アイドルタイムアウトとコネクション寿命を設定
- ステートメントタイムアウトを設定
- プール使用率の監視を実装

## 6. クエリ結果キャッシュ

キャッシュ戦略の詳細は `caching.md` を参照。

- クエリ + パラメータのハッシュをキャッシュキーに使用
- 読み取り頻度の高いクエリを優先的にキャッシュ
- データ変更時のキャッシュ無効化ルールを定義

## 7. 監視・プロファイリング

監視のセットアップ詳細は `monitoring.md` を参照。

- アクティブコネクション数、トランザクション率を監視
- テーブルサイズ、デッドタプル率を追跡
- ロック競合とデッドロックを監視
- レプリケーション遅延を監視 (レプリカ構成の場合)

## 8. リードレプリカ・負荷分散

- 書き込みはプライマリ、読み取りはレプリカに振り分け
- アプリケーション層でのルーティングロジックを実装
- レプリケーション遅延の許容範囲を定義
- フェイルオーバー戦略を策定

## 9. メンテナンス

- VACUUM / ANALYZE の自動実行を設定
- テーブル膨張 (bloat) を監視
- 統計情報の更新頻度を最適化
- 定期的なインデックス再構築を計画

## 10. パフォーマンステスト

- 代表的なクエリのベンチマークを作成
- 負荷テストでスケーラビリティを検証
- 最適化前後のメトリクスを比較・文書化
- 回帰テストで正確性を確認

See also: 全体的な監査は `performance-audit.md`、キャッシュ戦略は `caching.md` を参照。
