# キャッシュ戦略手順

多層キャッシュ戦略を以下の 10 ステップで設計・実装する。

## 1. キャッシュ戦略分析

- アプリケーションアーキテクチャを分析し、キャッシュ機会を特定
- 現在のパフォーマンスボトルネックとデータアクセスパターンを評価
- キャッシュ要件を定義 (TTL、無効化、一貫性)
- 多層キャッシュアーキテクチャを計画 (ブラウザ / CDN / アプリケーション / DB)
- キャッシュ技術とストレージソリューションを評価

## 2. ブラウザ・クライアントサイドキャッシュ

- HTTP キャッシュヘッダーを設定 (Cache-Control, ETag, Expires)
  - 静的アセット: `public, max-age=31536000` (1年、content-hash 付き)
  - API レスポンス: `private, max-age=300` (5分)
  - HTML: `no-cache` (常に再検証)
- Service Worker キャッシュを実装 (オフライン対応が必要な場合)

## 3. アプリケーションレベルキャッシュ

- **インメモリキャッシュ**: node-cache 等で頻繁アクセスデータをキャッシュ (TTL 付き)
- **分散キャッシュ**: Redis で複数インスタンス間のキャッシュを共有
- キャッシュキー設計: 一意性と検索効率のバランスを取る

## 4. データベースクエリキャッシュ

DB 最適化の詳細は `database-optimization.md` を参照。

- クエリ結果キャッシュ: SQL + パラメータのハッシュをキーにキャッシュ
- ORM レベルキャッシュ: Mongoose plugin 等のフレームワーク機能を活用
- 読み取り頻度の高いクエリを優先的にキャッシュ

## 5. API レスポンスキャッシュ

- GET リクエストのみキャッシュ (副作用なし)
- URL パスベースのキャッシュキーを使用
- GraphQL: persisted queries + response cache plugin を活用
- 認証済みリクエストはユーザー別キャッシュまたはキャッシュ除外

## 6. キャッシュ無効化戦略

- **イベント駆動**: データ変更時に関連キャッシュをパージ
- **TTL ベース**: 時間経過で自動期限切れ
- **パターンベース**: ワイルドカードで関連キャッシュを一括無効化
- **バージョニング**: キャッシュキーにバージョンを含めて世代管理

## 7. フロントエンドキャッシュ戦略

- React Query / SWR 等のデータフェッチライブラリのキャッシュ設定
  - staleTime: 再検証までの時間
  - cacheTime: メモリ上の保持時間
- LocalStorage / IndexedDB でオフラインデータを永続化

## 8. キャッシュ監視・分析

- キャッシュヒット率を計測 (目標: > 80%)
- キャッシュミス率が高いキーを特定
- メモリ使用量とエビクション頻度を監視
- キャッシュ効果をレスポンスタイムで検証

## 9. キャッシュウォーミング

- デプロイ後にポピュラーデータを事前ロード
- スケジュールベースのウォームアップ (cron)
- コールドスタート時の段階的ウォーミング戦略

## 10. テスト・検証

- キャッシュヒット/ミスの動作テスト
- TTL 期限切れと無効化のテスト
- 並行アクセス時のキャッシュ一貫性テスト
- パフォーマンス改善の計測 (キャッシュあり/なしの比較)

See also: CDN レベルのキャッシュは `cdn-optimization.md`、監視は `monitoring.md` を参照。
