---
description: 'Claude Code プロンプト（commands, agents, documents）を作成・編集したいとき'
disable-model-invocation: true
user-invocable: true
---

**重要**: コアとなるプロンプトエンジニアリングガイドラインにアクセスするため、`prompt-engineering` スキルを有効化してください。

<task_overview>
ユーザーの指示に基づいて Claude Code プロンプトを作成・更新・削除する。対象は以下:
- **Commands**: `/command-name` で呼び出し
- **Agents**: `@agent-name` または agent-task ツールで呼び出し
- **Documents**: 任意の場所に格納される汎用プロンプトドキュメント
- **Context Files**: CLAUDE.md, AGENTS.md, GEMINI.md（常時ロードコンテキスト）
</task_overview>

<decision_tree>
## プロンプトタイプの選択

適切なプロンプトタイプを決定するための決定木:

```
┌─ ユーザーは Skill の作成を求めているか？
│  └─ YES → `/skills:build-skill` コマンドにリダイレクト（Skill は専用ワークフローで管理）
│
├─ ユーザーは全セッションでコンテキストをロードする必要があるか？
│  ├─ YES → **Context File** を作成（.claude/CLAUDE.md, .gemini/GEMINI.md, .claude/.codex/AGENTS.md）
│  │  ユースケース:
│  │  - タスクの80%で必要なプロジェクト全体のコンテキスト
│  │  - 重要な制約と規約
│  │  - 詳細ドキュメントへのナビゲーション/インデックス
│  │  警告: 常時ロードのコストが高いため内容を最小限に
│  │
│  └─ NO（タスクの80%では不要） → 代替案を検討:
│     - タスク固有 → command/agent プロンプトに含める
│     - 詳細ガイドライン → docs/ ファイルを作成し、コンテキストから参照
│     - めったに使わない → LLM が探索で発見させる
│
├─ ユーザーはスラッシュコマンド呼び出し（例: /my-command）が必要か？
│  └─ YES → **Command** を作成（.claude/commands/<name>.md）
│
├─ ユーザーは特定のモデル/設定を持つ特化サブエージェントが必要か？
│  └─ YES → **Agent** を作成（.claude/agents/<name>.md）
│     ユースケース:
│     - メインセッションと異なるモデル（例: 速度のため haiku）
│     - 再利用可能な特化動作（例: コードレビュー、PR作成）
│     - agent-task ツール経由で Claude がプログラム的に呼び出し
│
└─ ユーザーは特別な呼び出しなしで再利用可能な指示が必要か？
   └─ YES → **Document** を作成（カスタムパス、例: docs/prompts/<name>.md）
      ユースケース:
      - 他のプロンプトの参照資料
      - チェックリストとガイドライン
      - 共有指示テンプレート
```
</decision_tree>

<execution_workflow>
## 実行ワークフロー

### ステップ1: プロンプトタイプの決定
ユーザーリクエストに基づき特定:
- **Context File**（`.claude/CLAUDE.md` など）: 毎セッションロードされるコンテキスト
- **Command**（`.claude/commands/`）: `/command-name` 呼び出しを希望
- **Agent**（`.claude/agents/`）: `@agent-name` または agent-task ツール使用を希望
- **Document**（カスタムパス）: 場所を指定または汎用ドキュメント

**Skill の場合**: `/skills:build-skill` コマンドを案内し、このワークフローは終了。

**Context File の場合**: 追加の精査を適用（詳細は prompt-engineering スキルを参照）

### ステップ2: 原則に基づく設計
prompt-engineering スキルのガイドラインを適用。

**スキルを必要とするエージェントの場合**:
- `skills` フロントマターフィールドを使用して必要なスキルを自動ロード
- ❌ 避ける: 本文での「**重要**: `typescript` スキルを有効化...」
- ✅ 推奨: フロントマターで `skills: [typescript, react]`
- 条件付き/動的スキルロードの場合のみ手動 `Skill(...)` を使用

**より深く考える**べきポイント:
- 単一責任: このプロンプトがする一つのことは何か？
- 呼び出し元からの独立: コンテキストなしで誰でも呼び出せるか？
- 本質的な情報のみ: 本当に必要なもの vs あると良いもの？
- 責任の境界: ここに属するもの vs CLAUDE.md に属するもの？

**オーケストレーター用**（サブエージェントを呼び出す commands/agents）:
- **呼び出しテンプレートは必須**: 各サブエージェントの呼び出し方を示す完全な agent-task ツール使用テンプレートを含める
- **テンプレートが重要な理由**: 一貫性を確保し、パターンを明示し、再現可能なオーケストレーションを実現
- **責任分割**: サブエージェントは汎用的・再利用可能に; タスク固有コンテキストはオーケストレーターのテンプレートに
- 詳細は prompt-engineering スキルの `<orchestration_patterns>` を参照

**Context Files の場合、特に慎重に考える**（prompt-engineering スキル参照）:
- **80%ルール**: 全ての情報がタスクの80%で必要か？
- **インデックス優先**: 詳細ドキュメントへのポインタで置き換えられるか？
- **発見可能性**: LLM が探索で見つけられるか？
- **コマンドの吟味**: LLM は典型タスクでこのコマンドを自律実行するか？
- **極度の簡潔さ**: さらに凝縮できるか？目標100行未満。
- **抽象度**: 地図（良い）を与えているか、領土（悪い）を与えているか？

### ステップ3: 簡潔に記述
簡潔さと明確さについて prompt-engineering スキルのガイドラインに従う。

### ステップ4: 初期検証
prompt-engineering スキルの自動チェックリストを実行。

### ステップ5: 並列レビューセッション
3つの並列 `prompt-reviewer` エージェントを起動して多様なフィードバックを取得。

**重要**: プロンプトがオーケストレーター（サブエージェントを呼び出す）の場合、レビュアーに以下をチェックさせる:
- 完全な呼び出しテンプレートの存在（必須要件）
- テンプレートの品質と完全性
- オーケストレーターとサブエージェント間の適切な責任分割

```
agent-task(
  agent="prompt-reviewer",
  message="以下のプロンプトをレビューしてください:\n\n[プロンプト内容]\n\n注: これはサブエージェントを呼び出すオーケストレータープロンプトです。呼び出しテンプレートが完全でベストプラクティスに従っているか確認してください。"
)
agent-task(
  agent="prompt-reviewer",
  message="以下のプロンプトをレビューしてください:\n\n[プロンプト内容]\n\n注: これはサブエージェントを呼び出すオーケストレータープロンプトです。呼び出しテンプレートが完全でベストプラクティスに従っているか確認してください。"
)
agent-task(
  agent="prompt-reviewer",
  message="以下のプロンプトをレビューしてください:\n\n[プロンプト内容]\n\n注: これはサブエージェントを呼び出すオーケストレータープロンプトです。呼び出しテンプレートが完全でベストプラクティスに従っているか確認してください。"
)
```

### ステップ6: フィードバックの集約と適用
- 3つのレビューセッションからフィードバックを収集
- レビュー間で共通の問題を特定
- critical と moderate の改善を適用
- コンテキストに基づいて minor の提案を検討
- 改善でプロンプトファイルを更新

### ステップ7: 最終確認
ファイルが正しく作成/更新されたことを確認し、完了をユーザーに報告。
</execution_workflow>
